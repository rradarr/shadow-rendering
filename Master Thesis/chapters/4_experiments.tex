\chapter{Experiments}
\label{section:chapter_4}
% This chapter presents the experiments. It is a crucial part of the thesis and has to dominate in the thesis. 
% The experiments and their analysis should be done in the way commonly accepted in the scientific community (eg. benchmark datasets, cross validation of elaborated results, reproducibility and replicability of tests etc).

\section{Methodology}
% \begin{itemize}
% \item description of methodology of experiments
% \item description of experimental framework (description of user interface of research applications â€“ move to an appendix)
% \end{itemize}
One of the objectives of the thesis was to compare multiple shadow rendering methods both in a qualitative and quantitative ways. To achieve this a test renderer application was created, which implements the rendering techniques and allows a user to observe their results as well as profile the performance the program.

The tests were performed in a semi-controlled environment. Care was taken to avoid other processes interrupting and affecting the test results, but their impact could not be entirely eliminated in. Results of repeated tests at different moments in time or on different machines with the same hardware will differ, but that difference should not be large enough to impact the overall comparison results. 
% TODO: if you use two machines, mention it here.
The machine used for performing measurements had the following specification:
\begin{itemize}
    \item OS: Windows 10, 22H2
    \item CPU: AMD Ryzen 5 1600
    \item GPU: Nvidia GTX 1080, 8 GB VRAM
    \item RAM: 16 GB
\end{itemize}

\subsection{Created test application}
The test application allows the user to choose a rendering mode and observe the results in real time. It also allows to change the viewpoint and observe how the shadows behave in motion. Most rendering modes implement different shadow rendering techniques and some include debug views like wireframe mode or mesh colored by normals. The application is also instrumented with profiling commands which make it possible to connect to an external profiler and collect data in real time, as well as save and load existing profiling data.

As mentioned in section \ref{chapter:3_test_app}, the Tracy profiler open source library and tool was used to gather and visualize profiling data. For additional profiling and debugging RenderDoc, PIX and Nsight Graphics were used.

\section{Data sets}
The data sets consist of multiple scenes used for testing. Three scenes, Crytek Sponza, Power Plant and Chinese Dragon are from the Computer Graphics Archive \cite{bib:internet:test_scenes}. The Crytek Sponza scene contains 262267 triangles and 184330 vertices. The Power Plant scene contains 12759246 triangles and 10614919 vertices. The Chinese Dragon contains 871306 triangles and 438929 vertices. They were chosen because they are standard test scenes in the computer graphics community, which are freely available on the internet. They also contain highly varying amounts of vertices, with the Power Plant scene having almost sixty times more vertices than Cytek Sponza, which allows to test the influence of geometric complexity on the performance of the algorithms. The Chinese Dragon scene is much more contained and showcases small-scale shadows and self-shadowing. Additionally, a simple scene containing a unit cube positioned on a ground plane was created in Blender. This scene contains only twenty-eight vertices. Its simplicity allows to easily spot differences in the appearance of shadows in the render and highlights issues such as peter-panning.

\section{Results}
% \begin{itemize}
% \item presentation of results, analysis and wide discussion of elaborated results, conclusions
% \end{itemize}

The results of testing each implemented shadow rendering method are presented in the following sections. Each set of results is complemented by a description and discussion.

\subsection{Planar shadow mapping}
Should I even test this?
% TODO.

\subsection{Basic shadow maps}
The basic implementation of shadow mapping from section \ref{section:basic_mapping_impl} was tested with all four scenes at different shadow map and output resolutions. The results are shown in Fig. \ref{fig:plot:basic_results}.
\begin{figure}[h]
\centering
\begin{subfigure}[t]{0.48\textwidth}
    \begin{tikzpicture}
        \begin{semilogxaxis}[
            small,
            xlabel={Shadow map resolution},
            ylabel={FPS},
            xtick={512,1024,2048,4096},
            xticklabels={512,1024,2048,4096},
            % legend style={
            %     overlay,
            %     at={(1.25,0.5)},
            %     anchor=center},
            y tick label style={
                /pgf/number format/.cd,
                    fixed,   % po zakomentowaniu os rzednych jest indeksowana wykladniczo
                    fixed, % 1.0 zamiast 1
                    precision=1,
                /tikz/.cd
            },
            x tick label style={
                /pgf/number format/.cd,
                    fixed,
                    fixed,
                    precision=2,
                /tikz/.cd
            }
            ]
            \addplot [color=green]
            coordinates {
                (512,1762)(1024,1746)(2048,1713)(4096,1631)}; %\addlegendentry{720p}
            \addplot [color=black]
            coordinates {
                (512,1458)(1024,1428)(2048,1402)(4096,1363)}; %\addlegendentry{1080p}
            \addplot [color=brown]
            coordinates {
                (512,1243)(1024,1268)(2048,1240)(4096,1192)}; %\addlegendentry{2k}
        \end{semilogxaxis} 
    \end{tikzpicture}
    \caption{Results for Chinese Dragon scene.}
    \label{fig:plot:basic_dragon}
\end{subfigure}
\hfill
\begin{subfigure}[t]{0.48\textwidth}
    \begin{tikzpicture}
        \begin{semilogxaxis}[
            small,
            xlabel={Shadow map resolution},
            ylabel={FPS},
            xtick={512,1024,2048,4096},
            xticklabels={512,1024,2048,4096},
            % legend style={
            %     overlay,
            %     at={(1.25,0.5)},
            %     anchor=center},
            y tick label style={
                /pgf/number format/.cd,
                    fixed,   % po zakomentowaniu os rzednych jest indeksowana wykladniczo
                    fixed, % 1.0 zamiast 1
                    precision=1,
                /tikz/.cd
            },
            x tick label style={
                /pgf/number format/.cd,
                    fixed,
                    fixed,
                    precision=2,
                /tikz/.cd
            }
            ]
            \addplot [color=green]
            coordinates {
                (512,2974)(1024,2983)(2048,3025)(4096,2998)}; %\addlegendentry{720p}
            \addplot [color=black]
            coordinates {
                (512,3017)(1024,2978)(2048,3031)(4096,3082)}; %\addlegendentry{1080p}
            \addplot [color=brown]
            coordinates {
                (512,3015)(1024,3019)(2048,3082)(4096,3092)}; %\addlegendentry{2k}
        \end{semilogxaxis} 
    \end{tikzpicture}
    \caption{Results for the Cube scene.}
    \label{fig:plot:basic_cube}
\end{subfigure}

\vspace{20pt}
\begin{subfigure}[t]{0.48\textwidth}
    \begin{tikzpicture}
        \begin{semilogxaxis}[
            small,
            xlabel={Shadow map resolution},
            ylabel={FPS},
            xtick={512,1024,2048,4096},
            xticklabels={512,1024,2048,4096},
            % legend style={
            %     overlay,
            %     at={(1.25,0.5)},
            %     anchor=center},
            y tick label style={
                /pgf/number format/.cd,
                    fixed,   % po zakomentowaniu os rzednych jest indeksowana wykladniczo
                    fixed, % 1.0 zamiast 1
                    precision=1,
                /tikz/.cd
            },
            x tick label style={
                /pgf/number format/.cd,
                    fixed,
                    fixed,
                    precision=2,
                /tikz/.cd
            }
            ]
            \addplot [color=green]
            coordinates {
                (512,259)(1024,261)(2048,251)(4096,230)}; %\addlegendentry{720p}
            \addplot [color=black]
            coordinates {
                (512,250)(1024,251)(2048,243)(4096,223)}; %\addlegendentry{1080p}
            \addplot [color=brown]
            coordinates {
                (512,240)(1024,240)(2048,232)(4096,213)}; %\addlegendentry{2k}
        \end{semilogxaxis} 
    \end{tikzpicture}
    \caption{Results for the Power Plant scene.}
    \label{fig:plot:basic_power}
\end{subfigure}
\hfill
\begin{subfigure}[t]{0.48\textwidth}
    \begin{tikzpicture}
        \begin{semilogxaxis}[
            small,
            xlabel={Shadow map resolution},
            ylabel={FPS},
            xtick={512,1024,2048,4096},
            xticklabels={512,1024,2048,4096},
            % legend style={
            %     overlay,
            %     at={(1.25,0.5)},
            %     anchor=center},
            y tick label style={
                /pgf/number format/.cd,
                    fixed,   % po zakomentowaniu os rzednych jest indeksowana wykladniczo
                    fixed, % 1.0 zamiast 1
                    precision=1,
                /tikz/.cd
            },
            x tick label style={
                /pgf/number format/.cd,
                    fixed,
                    fixed,
                    precision=2,
                /tikz/.cd
            }
            ]
            \addplot [color=green]
            coordinates {
                (512,3098)(1024,3072)(2048,2986)(4096,2213)}; %\addlegendentry{720p}
            \addplot [color=black]
            coordinates {
                (512,2912)(1024,2795)(2048,2467)(4096,1750)}; %\addlegendentry{1080p}
            \addplot [color=brown]
            coordinates {
                (512,2116)(1024,2038)(2048,1852)(4096,1416)}; %\addlegendentry{2k}
        \end{semilogxaxis} 
    \end{tikzpicture}
    \caption{Results for the Crytek Sponza scene.}
    \label{fig:plot:basic_sponza}
\end{subfigure}
\caption{Frames per second for all test scenes, for different sizes of the shadow map and output resolutions. In green \(1280\times 720\), in black \(1920\times 1080\) and in brown \(2560\times 1440\). Rendering with the basic shadow map implementation.}
\label{fig:plot:basic_results}
\end{figure}

The test results mostly match the expectation that fewer FPS will be produced with increasing shadow map resolution and output resolution. The only exception is plot \ref{fig:plot:basic_cube} of the Cube scene results. This is however probably due to the fact that this scene is so simple, and in effect is rendered with such high FPS (highest in this test set, over 3000), that any interruptions from other programs on the machine will be visible. Inconsistencies might also be produced by hardware cores' dynamic clock rates, which can vary over the duration of the test.

The basic shadow mapping algorithm is simple enough to produce high FPS. Even in the most complex scene, the Power Plant, over 210 frames are rendered at 2k output and 4k shadow map resolution.

Looking at the shapes of the plots, it can be said that the basic shadow mapping algorithm is not dependent on output resolution. The lower FPS for higher output resolutions stem mostly from the sole fact that more pixel need to be rendered, because the FPS falloffs along the x-axis follow the same shape. In most cases the drop in FPS between the lowest and highest shadow map resolution is the same, regardless of the output resolution. 

The plots have their x-axis in logarithmic scale. Taking that into account, it can be observed that the FPS counts fall linearly with growing shadow map resolutions.

The algorithm's performance is not view-dependent. When traversing the scene the frame rates are stable. This is backed by the fact that in basic shadow mapping the same work is performed for each rendered pixel, consisting of a comparison operation with the depth value stored in the depth map. This however would not be true if shadow map fitting was used. In such case, the performance will become view dependent as more or less geometry will be rendered into the shadow map. This can provide a useful performance boost in large scenes.

Using the Tracy profiler it can be confirmed that the renderer's performance is limited by the computations performed on the GPU, as the CPU thread spent approximately \(30\%\) of time waiting for the GPU resources to be available. Tracy also reports that approximately \(40\%\) of the frame time was spent on the shadow map render pass and \(52\%\) on the main render pass. The remaining time was spent rendering the GUI and synchronizing. This can be expected as with this simple technique the shadow map pass is almost as expensive as the main pass. The main pass is slightly more involved as it outputs pixels and performs simple shading, as well as performs the shadow mapping itself, which requires texture lookups and comparisons that add time.

The rendering results for the Chinese Dragon are presented in Fig. \ref{fig:test_basic_dragon_screens} and in Fig. \ref{fig:test_basic_sponza_screens} the Crytek Sponza is presented.
\begin{figure}
    \centering
    \begin{subfigure}{0.48\textwidth}
		\centering
        \includegraphics[width=\textwidth]{./graf/tests/basic/cropped/dragon_basic_fhd_512.png}
        \caption{The Chinese Dragon rendered with \(512\times 512\) shadow map.}
    \end{subfigure}
	\hfill
    \begin{subfigure}{0.48\textwidth}
		\centering
        \includegraphics[width=\textwidth]{./graf/tests/basic/cropped/dragon_basic_fhd_1024.png}
        \caption{The Chinese Dragon rendered with \(1024\times 1024\) shadow map.}
    \end{subfigure}

    \begin{subfigure}{0.48\textwidth}
		\centering
        \includegraphics[width=\textwidth]{./graf/tests/basic/cropped/dragon_basic_fhd_2048.png}
        \caption{The Chinese Dragon rendered with \(2048\times 2048\) shadow map.}
    \end{subfigure}
	\hfill
    \begin{subfigure}{0.48\textwidth}
		\centering
        \includegraphics[width=\textwidth]{./graf/tests/basic/cropped/dragon_basic_fhd_4096.png}
        \caption{The Chinese Dragon rendered with \(4096\times 4096\) shadow map.}
    \end{subfigure}

    \caption{The Chinese Dragon scene rendered with different shadow map resolutions, using the basic shadow mapping algorithm.}
    \label{fig:test_basic_dragon_screens}
\end{figure}
\begin{figure}[t]
    \centering
    \begin{subfigure}{0.48\textwidth}
		\centering
        \includegraphics[width=\textwidth]{./graf/tests/basic/cropped/sponza_basic_fhd_512.png}
        \caption{The Crytek Sponza rendered with \(512\times 512\) shadow map.}
    \end{subfigure}
	\hfill
    \begin{subfigure}{0.48\textwidth}
		\centering
        \includegraphics[width=\textwidth]{./graf/tests/basic/cropped/sponza_basic_fhd_1024.png}
        \caption{The Crytek Sponza rendered with \(1024\times 1024\) shadow map.}
    \end{subfigure}

    \begin{subfigure}{0.48\textwidth}
		\centering
        \includegraphics[width=\textwidth]{./graf/tests/basic/cropped/sponza_basic_fhd_2048.png}
        \caption{The Crytek Sponza rendered with \(2048\times 2048\) shadow map.}
    \end{subfigure}
	\hfill
    \begin{subfigure}{0.48\textwidth}
		\centering
        \includegraphics[width=\textwidth]{./graf/tests/basic/cropped/sponza_basic_fhd_4096.png}
        \caption{The Crytek Sponza rendered with \(4096\times 4096\) shadow map.}
    \end{subfigure}

    \caption{The Crytek Sponza scene rendered with different shadow map resolutions, using the basic shadow mapping algorithm.}
    \label{fig:test_basic_sponza_screens}
\end{figure}

The Chinese Dragon results are quite good for higher resolution shadow maps, since the shadow map texels map many to one with regard to screen pixels. Aliasing is however very visible for lower resolutions. Crytek Sponza suffers from shadow acne on vertical surfaces. This is a sign of badly chosen shadow bias. It gets less visible as resolution rises, but is always present. Even at the highest resolution, shadow map texel borders are still visible, where they were not visible in the Chinese Dragon scene. This is due to the fact that the shadow map covers a larger area and each shadow map texel covers more space on the screen.

The memory usage is wholly dependent on the resolution of the shadow map. If memory is very scarce a depth buffer of lower precision can be used, but that is unlikely on modern graphics hardware to be the case. The depth map in this case was created to store the depth in 24 bits, plus additional 8 bits for the stencil buffer, totaling 32 bits per shadow map texel.

\subsection{Filtered shadow maps}
The following sections present experiments and their results performed using the implementations of different filtering techniques for shadow maps, which were described in sections \ref{section:filtering_shadow_maps} and \ref{section:pcf}.

\subsubsection{Hardware bilinear filtering}
\label{section:test_bilinear}
Hardware bilinear filtering is considered a simple filtering method that can improve appearance of shadows generated with shadow maps with practically no performance cost. This is tested for different output and shadow map resolutions in different test scenes and the results are presented in Fig. \ref{fig:plot:bilinear_results}.

\begin{figure}[h]
    \centering
    \begin{subfigure}[t]{0.48\textwidth}
        \begin{tikzpicture}
            \begin{semilogxaxis}[
                small,
                xlabel={Shadow map resolution},
                ylabel={FPS},
                xtick={512,1024,2048,4096},
                xticklabels={512,1024,2048,4096},
                % legend style={
                %     overlay,
                %     at={(1.25,0.5)},
                %     anchor=center},
                y tick label style={
                    /pgf/number format/.cd,
                        fixed,   % po zakomentowaniu os rzednych jest indeksowana wykladniczo
                        fixed, % 1.0 zamiast 1
                        precision=1,
                    /tikz/.cd
                },
                x tick label style={
                    /pgf/number format/.cd,
                        fixed,
                        fixed,
                        precision=2,
                    /tikz/.cd
                }
                ]
                \addplot [color=green]
                coordinates {
                    (512,1765)(1024,1722)(2048,1695)(4096,1612)}; %\addlegendentry{720p}
                \addplot [color=black]
                coordinates {
                    (512,1426)(1024,1416)(2048,1392)(4096,1334)}; %\addlegendentry{1080p}
                \addplot [color=brown]
                coordinates {
                    (512,1267)(1024,1258)(2048,1244)(4096,1201)}; %\addlegendentry{2k}
            \end{semilogxaxis} 
        \end{tikzpicture}
        \caption{Results for Chinese Dragon scene.}
        \label{fig:plot:bilinear_dragon}
    \end{subfigure}
    \hfill
    \begin{subfigure}[t]{0.48\textwidth}
        \begin{tikzpicture}
            \begin{semilogxaxis}[
                small,
                xlabel={Shadow map resolution},
                ylabel={FPS},
                xtick={512,1024,2048,4096},
                xticklabels={512,1024,2048,4096},
                % legend style={
                %     overlay,
                %     at={(1.25,0.5)},
                %     anchor=center},
                y tick label style={
                    /pgf/number format/.cd,
                        fixed,   % po zakomentowaniu os rzednych jest indeksowana wykladniczo
                        fixed, % 1.0 zamiast 1
                        precision=1,
                    /tikz/.cd
                },
                x tick label style={
                    /pgf/number format/.cd,
                        fixed,
                        fixed,
                        precision=2,
                    /tikz/.cd
                }
                ]
                \addplot [color=green]
                coordinates {
                    (512,2932)(1024,2973)(2048,3027)(4096,2904)}; %\addlegendentry{720p}
                \addplot [color=black]
                coordinates {
                    (512,2912)(1024,2861)(2048,2923)(4096,3027)}; %\addlegendentry{1080p}
                \addplot [color=brown]
                coordinates {
                    (512,2987)(1024,3063)(2048,2948)(4096,3072)}; %\addlegendentry{2k}
            \end{semilogxaxis} 
        \end{tikzpicture}
        \caption{Results for the Cube scene.}
        \label{fig:plot:bilinear_cube}
    \end{subfigure}
    
    \vspace{20pt}
    \begin{subfigure}[t]{0.48\textwidth}
        \begin{tikzpicture}
            \begin{semilogxaxis}[
                small,
                xlabel={Shadow map resolution},
                ylabel={FPS},
                xtick={512,1024,2048,4096},
                xticklabels={512,1024,2048,4096},
                % legend style={
                %     overlay,
                %     at={(1.25,0.5)},
                %     anchor=center},
                y tick label style={
                    /pgf/number format/.cd,
                        fixed,   % po zakomentowaniu os rzednych jest indeksowana wykladniczo
                        fixed, % 1.0 zamiast 1
                        precision=1,
                    /tikz/.cd
                },
                x tick label style={
                    /pgf/number format/.cd,
                        fixed,
                        fixed,
                        precision=2,
                    /tikz/.cd
                }
                ]
                \addplot [color=green]
                coordinates {
                    (512,257)(1024,258)(2048,251)(4096,228)}; %\addlegendentry{720p}
                \addplot [color=black]
                coordinates {
                    (512,251)(1024,250)(2048,243)(4096,223)}; %\addlegendentry{1080p}
                \addplot [color=brown]
                coordinates {
                    (512,239)(1024,239)(2048,233)(4096,212)}; %\addlegendentry{2k}
            \end{semilogxaxis} 
        \end{tikzpicture}
        \caption{Results for the Power Plant scene.}
        \label{fig:plot:bilinear_power}
    \end{subfigure}
    \hfill
    \begin{subfigure}[t]{0.48\textwidth}
        \begin{tikzpicture}
            \begin{semilogxaxis}[
                small,
                xlabel={Shadow map resolution},
                ylabel={FPS},
                xtick={512,1024,2048,4096},
                xticklabels={512,1024,2048,4096},
                % legend style={
                %     overlay,
                %     at={(1.25,0.5)},
                %     anchor=center},
                y tick label style={
                    /pgf/number format/.cd,
                        fixed,   % po zakomentowaniu os rzednych jest indeksowana wykladniczo
                        fixed, % 1.0 zamiast 1
                        precision=1,
                    /tikz/.cd
                },
                x tick label style={
                    /pgf/number format/.cd,
                        fixed,
                        fixed,
                        precision=2,
                    /tikz/.cd
                }
                ]
                \addplot [color=green]
                coordinates {
                    (512,2884)(1024,3021)(2048,2854)(4096,2162)}; %\addlegendentry{720p} here at 4k drpos <10 fps visible
                \addplot [color=black]
                coordinates {
                    (512,2825)(1024,2736)(2048,2414)(4096,1726)}; %at 4k shadow map, visible difference of few fps, sometimes... %\addlegendentry{1080p}
                \addplot [color=brown]
                coordinates {
                    (512,2075)(1024,2022)(2048,1836)(4096,1411)}; %\addlegendentry{2k}
            \end{semilogxaxis} 
        \end{tikzpicture}
        \caption{Results for the Crytek Sponza scene.}
        \label{fig:plot:bilinear_sponza}
    \end{subfigure}
    \caption{Frames per second for all test scenes, for different sizes of the shadow map and output resolutions. In green \(1280\times 720\), in black \(1920\times 1080\) and in brown \(2560\times 1440\). Rendering with the basic shadow mapping technique with bilinear filtering enabled.}
    \label{fig:plot:bilinear_results}
\end{figure}

The results are very similar, with no immediately visible drop in performance. Taking the Power Plant scene as an example, the FPS range measured at Full HD output resolution is \([251:223]\). In the shadow mapping without filtering test the FPS range was \([250:223]\). The results are the same when accounting for instabilities caused by other software and dynamic clock rates. This is interesting when compared to results of Crytek Sponza tests, where the Full HD range was \([2825:1726]\) with bilinear filtering and  \([2912:1750]\) without. Here, a significant drop in performance can be seen when using bilinear filtering. This might be caused by the fact FPS measurements are more sensitive in higher rages, as 1 FPS difference at 250 FPS is equal to 0.016ms, while 1 FPS difference at 2800 FPS is equal to only 0,000127ms. This is somewhat visible in the Crytek Sponza FPS ranges, as the upper ends have a higher difference between them than lower ends. Additionally, since the Power Plant is a much heavier scene performance-wise, the GPU has much more work to perform and the slowdown from using bilinear filtering can get masked better. When toggling bilinear filtering on and off during testing, the FPS readout would most of the time stay stable within reasonable FPS ranges. It seems that the cost of hardware bilinear filtering is indeed insignificant in realistic scenarios, where the GPU is fully utilized.

The effect on the final rendered result is on the other hand very significant, especially at lower shadow map resolutions, as presented in figure \ref{fig:test_bilinear_dragon_screens}. The shadow boundaries get smoother, which improves the visuals even at low shadow map resolutions. The texels are less noticeable and the shape is more easily readable as a shadow.

\begin{figure}[h]
    \centering
    \begin{subfigure}[t]{0.48\textwidth}
		\centering
        \includegraphics[width=\textwidth]{./graf/tests/basic/cropped/dragon_basic_fhd_512.png}
        \caption{The Chinese Dragon rendered with a \(512\times 512\) shadow map with no filtering.}
    \end{subfigure}
	\hfill
    \begin{subfigure}[t]{0.48\textwidth}
		\centering
        \includegraphics[width=\textwidth]{./graf/tests/bilinear/cropped/dragon_bilinear_fhd_512.png}
        \caption{The Chinese Dragon rendered with a \(512\times 512\) shadow map with bilinear filtering.}
    \end{subfigure}
    \begin{subfigure}[t]{0.48\textwidth}
		\centering
        \includegraphics[width=\textwidth]{./graf/tests/basic/cropped/dragon_basic_fhd_4096.png}
        \caption{The Chinese Dragon rendered with a \(4096\times 4096\) shadow map with no filtering.}
    \end{subfigure}
	\hfill
    \begin{subfigure}[t]{0.48\textwidth}
		\centering
        \includegraphics[width=\textwidth]{./graf/tests/bilinear/cropped/dragon_bilinear_fhd_4096.png}
        \caption{The Chinese Dragon rendered with a \(4096\times 4096\) shadow map with bilinear filtering.}
    \end{subfigure}

    \caption{The Chinese Dragon rendered with and without bilinear comparison filtering.}
    \label{fig:test_bilinear_dragon_screens}
\end{figure}

Unfortunately, this filtering means that biasing has to be adjusted, as samples will be taken around the original position. This results in visible shadow acne, especially at lower shadow map resolutions, where shadow map texels cover a larger area on screen. It's noteworthy that, while there will be more pixels that erroneously self-shadow, the contrast of such artifacts will be smaller. This can help hide them at higher shadow map resolutions.

\subsubsection{Percentage-closer filtering}
PCF is another filtering technique that allows for the creation of arbitrarily sized filter kernels used to filter the results of shadow computations. For the performance tests, the shadow map resolution will be kept constant to measure how kernel size and output resolution affect the FPS counts. Shadow map resolution does not impact the results in the context of this technique, apart from the performance degradation with higher shadow map resolutions observed in previous tests. The results for all scenes, for different square filter kernel sizes and output resolutions are presented in Fig. \ref{fig:plot:pcf_results}.
\begin{figure}[h]
    \centering
    \begin{subfigure}[t]{0.48\textwidth}
        \begin{tikzpicture}
            \begin{axis}[
                small,
                xlabel={Filter kernel size},
                ylabel={FPS},
                xtick={3,5,7,9,11},
                xticklabels={3,5,7,9,11},
                % legend style={
                %     overlay,
                %     at={(1.25,0.5)},
                %     anchor=center},
                y tick label style={
                    /pgf/number format/.cd,
                        fixed,   % po zakomentowaniu os rzednych jest indeksowana wykladniczo
                        fixed, % 1.0 zamiast 1
                        precision=1,
                    /tikz/.cd
                },
                x tick label style={
                    /pgf/number format/.cd,
                        fixed,
                        fixed,
                        precision=2,
                    /tikz/.cd
                }
                ]
                \addplot [color=green]
                coordinates {
                    (3,1087)(5,410)(7,220)(9,139)(11,96)}; %\addlegendentry{720p}
                \addplot [color=black]
                coordinates {
                    (3,654)(5,228)(7,118)(9,73)(11,50)}; %\addlegendentry{1080p}
                \addplot [color=brown]
                coordinates {
                    (3,443)(5,144)(7,74)(9,46)(11,31)}; %\addlegendentry{2k}
            \end{axis} 
        \end{tikzpicture}
        \caption{Results for Chinese Dragon scene.}
        \label{fig:plot:pcf_dragon}
    \end{subfigure}
    \hfill
    \begin{subfigure}[t]{0.48\textwidth}
        \begin{tikzpicture}
            \begin{axis}[
                small,
                xlabel={Filter kernel size},
                ylabel={FPS},
                xtick={3,5,7,9,11},
                xticklabels={3,5,7,9,11},
                % legend style={
                %     overlay,
                %     at={(1.25,0.5)},
                %     anchor=center},
                y tick label style={
                    /pgf/number format/.cd,
                        fixed,   % po zakomentowaniu os rzednych jest indeksowana wykladniczo
                        fixed, % 1.0 zamiast 1
                        precision=1,
                    /tikz/.cd
                },
                x tick label style={
                    /pgf/number format/.cd,
                        fixed,
                        fixed,
                        precision=2,
                    /tikz/.cd
                }
                ]
                \addplot [color=green]
                coordinates {
                    (3,2783)(5,980)(7,498)(9,300)(11,203)}; %\addlegendentry{720p}
                \addplot [color=black]
                coordinates {
                    (3,1610)(5,462)(7,228)(9,137)(11,93)}; %\addlegendentry{1080p}
                \addplot [color=brown]
                coordinates {
                    (3,945)(5,260)(7,128)(9,78)(11,52)}; %\addlegendentry{2k}
            \end{axis} 
        \end{tikzpicture}
        \caption{Results for the Cube scene.}
        \label{fig:plot:pcf_cube}
    \end{subfigure}

    \vspace{20pt}
    \begin{subfigure}[t]{0.48\textwidth}
        \begin{tikzpicture}
            \begin{axis}[
                small,
                xlabel={Filter kernel size},
                ylabel={FPS},
                xtick={3,5,7,9,11},
                xticklabels={3,5,7,9,11},
                % legend style={
                %     overlay,
                %     at={(1.25,0.5)},
                %     anchor=center},
                y tick label style={
                    /pgf/number format/.cd,
                        fixed,   % po zakomentowaniu os rzednych jest indeksowana wykladniczo
                        fixed, % 1.0 zamiast 1
                        precision=1,
                    /tikz/.cd
                },
                x tick label style={
                    /pgf/number format/.cd,
                        fixed,
                        fixed,
                        precision=2,
                    /tikz/.cd
                }
                ]
                \addplot [color=green]
                coordinates {
                    (3,223)(5,153)(7,100)(9,70)(11,51)}; %\addlegendentry{720p}
                \addplot [color=black]
                coordinates {
                    (3,188)(5,102)(7,61)(9,40)(11,28)}; %\addlegendentry{1080p}
                \addplot [color=brown]
                coordinates {
                    (3,155)(5,72)(7,40)(9,25)(11,18)}; %\addlegendentry{2k}
            \end{axis} 
        \end{tikzpicture}
        \caption{Results for the Power Plant scene.}
        \label{fig:plot:pcf_power}
    \end{subfigure}
    \hfill
    \begin{subfigure}[t]{0.48\textwidth}
        \begin{tikzpicture}
            \begin{axis}[
                small,
                xlabel={Filter kernel size},
                ylabel={FPS},
                xtick={3,5,7,9,11},
                xticklabels={3,5,7,9,11},
                % legend style={
                %     overlay,
                %     at={(1.25,0.5)},
                %     anchor=center},
                y tick label style={
                    /pgf/number format/.cd,
                        fixed,   % po zakomentowaniu os rzednych jest indeksowana wykladniczo
                        fixed, % 1.0 zamiast 1
                        precision=1,
                    /tikz/.cd
                },
                x tick label style={
                    /pgf/number format/.cd,
                        fixed,
                        fixed,
                        precision=2,
                    /tikz/.cd
                }
                ]
                \addplot [color=green]
                coordinates {
                    (3,920)(5,311)(7,160)(9,98)(11,67)}; %\addlegendentry{720p}
                \addplot [color=black]
                coordinates {
                    (3,500)(5,156)(7,79)(9,48)(11,34)}; %\addlegendentry{1080p}
                \addplot [color=brown]
                coordinates {
                    (3,306)(5,94)(7,47)(9,29)(11,19)}; %\addlegendentry{2k}
            \end{axis} 
        \end{tikzpicture}
        \caption{Results for the Crytek Sponza scene.}
        \label{fig:plot:pcf_sponza}
    \end{subfigure}
    \caption{Frames per second for all test scenes, for different sizes of the filter kernel and output resolutions. In green \(1280\times 720\), in black \(1920\times 1080\) and in brown \(2560\times 1440\). Rendering with the basic shadow mapping technique with PCF at constant shadow map size \(1024\times 1024\).}
    \label{fig:plot:pcf_results}
\end{figure}

The results show performance dropping exponentially with regard to increasing filter kernel size. This is expected, as for a kernel of size \(n\) there are \(n^2\) depth comparisons performed. This fact makes high kernel sizes impractical and limits the usability of the approach. A larger smoothing effect is better achieved by using a scale factor to scale the sample offsets within the filter kernel than by increasing the kernel size.

\begin{figure}[p]
    \centering
    \begin{subfigure}[t]{0.48\textwidth}
		\centering
        \includegraphics[width=\textwidth]{./graf/tests/pcf/cropped/dragon_pcf_fhd_1024_3x3.png}
        \caption{The shadow of the Chinese Dragon filtered with a \(3\times 3\) kernel.}
    \end{subfigure}
	\hfill
    \begin{subfigure}[t]{0.48\textwidth}
		\centering
        \includegraphics[width=\textwidth]{./graf/tests/pcf/cropped/dragon_pcf_fhd_1024_11x11.png}
        \caption{The shadow of the Chinese Dragon filtered with an \(11\times 11\) kernel.}
    \end{subfigure}

    \begin{subfigure}[t]{0.48\textwidth}
		\centering
        \includegraphics[width=\textwidth]{./graf/tests/pcf/cropped/dragon_pcf_fhd_1024_3x3_offset05.png}
        \caption{The shadow of the Chinese Dragon filtered with a \(3\times 3\) kernel and a scale of \(0.5\) applied to each kernel offset.}
    \end{subfigure}
    \hfill
    \begin{subfigure}[t]{0.48\textwidth}
		\centering
        \includegraphics[width=\textwidth]{./graf/tests/pcf/cropped/dragon_pcf_fhd_1024_11x11_offset05.png}
        \caption{The shadow of the Chinese Dragon filtered with an \(11\times 11\) kernel and a scale of \(0.5\) applied to each kernel offset.}
    \end{subfigure}

    \begin{subfigure}[t]{0.48\textwidth}
		\centering
        \includegraphics[width=\textwidth]{./graf/tests/pcf/cropped/dragon_pcf_fhd_1024_3x3_offset3.png}
        \caption{The shadow of the Chinese Dragon filtered with a \(3\times 3\) kernel and a scale of \(3\) applied to each kernel offset.}
    \end{subfigure}
	\hfill
    \begin{subfigure}[t]{0.48\textwidth}
		\centering
        \includegraphics[width=\textwidth]{./graf/tests/pcf/cropped/dragon_pcf_fhd_1024_11x11_offset3.png}
        \caption{The shadow of the Chinese Dragon filtered with an \(11\times 11\) kernel and a scale of \(3\) applied to each kernel offset.}
    \end{subfigure}    

    \caption{The Chinese Dragon rendered with \(3\times 3\) and \(11\times 11\) kernels with different offset scales.}
    \label{fig:test_pcf_dragon_screens}
\end{figure}

During testing interesting behavior was observed. In all tests, when the application was running with its initial kernel parameter unchanged, the frame rate would be much higher than at the same kernel size after any change to it was made. This difference in some cases was as large as the entire FPS value after a change, meaning the loss of half the frame rate. The reason for this is not known, because default initialization and optimization of the code path is unlikely, as neither the shader code nor the compiler know of the initial settings that will be used for the kernel size. All results shown in Fig. \ref{fig:plot:pcf_results} present FPS values after the initial change was made.

The appearance of shadows rendered with different sizes of kernels and offsets is presented in Fig. \ref{fig:test_pcf_dragon_screens}.
Banding is very much visible in the smoothed areas of the shadows, even with the largest kernel. This is because of the limited range of shades that can be produced in these transitional areas. A transition that appears smoother can be achieved by setting a smaller than 1 offset scale, but that limits the size of the smoothed shadow areas. Additionally, texel boundaries are always visible with this method.

The usage of even the smallest \(3\times 3\) kernel requires adjusting the depth bias to get clean results. The larger the kernel, the more bias is needed. This could be partially alleviated by using the distance from the kernel center to scale a bias that is added before the comparison happens, but overall bias would still depend on receiver orientations and would need to be adjusted per-scene.

\begin{figure}[h]
    \centering
    \begin{subfigure}[t]{0.45\textwidth}
		\centering
        \includegraphics[width=\textwidth]{./graf/tests/pcf/cropped/dragon_pcf_fhd_512_3x3.png}
        \caption{The Chinese Dragon rendered with basic \(3\times 3\) PCF.}
    \end{subfigure}
	\hfill
    \begin{subfigure}[t]{0.45\textwidth}
		\centering
        \includegraphics[width=\textwidth]{./graf/tests/pcf/cropped/dragon_pcf_fhd_512_3x3_bilinear.png}
        \caption{The Chinese Dragon rendered with \(3\times 3\) PCF enhanced by bilinear filtering.}
    \end{subfigure}
    \begin{subfigure}[t]{0.45\textwidth}
		\centering
        \includegraphics[width=\textwidth]{./graf/tests/pcf/cropped/dragon_pcf_fhd_512_11x11.png}
        \caption{The Chinese Dragon rendered with basic \(11\times 11\) PCF.}
    \end{subfigure}
	\hfill
    \begin{subfigure}[t]{0.45\textwidth}
		\centering
        \includegraphics[width=\textwidth]{./graf/tests/pcf/cropped/dragon_pcf_fhd_512_11x11_bilinear.png}
        \caption{The Chinese Dragon rendered with \(11\times 11\) PCF enhanced by bilinear filtering.}
    \end{subfigure}

    \caption{The Chinese Dragon rendered with PCF and with and without additional bilinear comparison filtering, using a \(512\times 512\) shadow map resolution.}
    \label{fig:test_pfc_bilinear_dragon_screens}
\end{figure}

The performance cost and underwhelming results make this technique mainly a stepping stone for more robust approaches. It is not practical to use it in real applications that need to run in real time. There is however one adjustment that can be made to significantly improve the shadow's appearance produced by PCF. As established in section \ref{section:test_bilinear}, hardware bilinear comparison filtering comes at virtually no performance cost. It can be applied to PCF, the results of which are shown in Fig. \ref{fig:test_pfc_bilinear_dragon_screens}

These results show that bilinear comparison filtering combined with PCF can lead to a great improvement of the visuals, even at kernel sizes as small as \(3\times 3\). Additionally, the shadow map used there has only \(512\times 512\) resolution, making it a very performant option. The impractical kernel size \(11\times 11\), when combined with bilinear filtering gives very smooth results, without any banding, hiding the texel boundaries very well, especially considering the low resolution of the shadow map.

\subsubsection{Adaptive percentage-closer filtering}

\subsection{Soft shadows with shadow maps}

\subsubsection{PCSS}

% \begin{table}
% \centering
% \caption{A caption of a table is ABOVE it.}
% \label{id:tab:wyniki}
% \begin{tabular}{rrrrrrrr}
% \toprule
% 	         &                                     \multicolumn{7}{c}{method}                                      \\
% 	         \cmidrule{2-8}
% 	         &         &         &        \multicolumn{3}{c}{alg. 3}        & \multicolumn{2}{c}{alg. 4, $\gamma = 2$} \\
% 	         \cmidrule(r){4-6}\cmidrule(r){7-8}
% 	$\zeta$ &     alg. 1 &   alg. 2 & $\alpha= 1.5$ & $\alpha= 2$ & $\alpha= 3$ &   $\beta = 0.1$  &   $\beta = -0.1$ \\
% \midrule
% 	       0 &  8.3250 & 1.45305 &       7.5791 &    14.8517 &    20.0028 & 1.16396 &                       1.1365 \\
% 	       5 &  0.6111 & 2.27126 &       6.9952 &    13.8560 &    18.6064 & 1.18659 &                       1.1630 \\
% 	      10 & 11.6126 & 2.69218 &       6.2520 &    12.5202 &    16.8278 & 1.23180 &                       1.2045 \\
% 	      15 &  0.5665 & 2.95046 &       5.7753 &    11.4588 &    15.4837 & 1.25131 &                       1.2614 \\
% 	      20 & 15.8728 & 3.07225 &       5.3071 &    10.3935 &    13.8738 & 1.25307 &                       1.2217 \\
% 	      25 &  0.9791 & 3.19034 &       5.4575 &     9.9533 &    13.0721 & 1.27104 &                       1.2640 \\
% 	      30 &  2.0228 & 3.27474 &       5.7461 &     9.7164 &    12.2637 & 1.33404 &                       1.3209 \\
% 	      35 & 13.4210 & 3.36086 &       6.6735 &    10.0442 &    12.0270 & 1.35385 &                       1.3059 \\
% 	      40 & 13.2226 & 3.36420 &       7.7248 &    10.4495 &    12.0379 & 1.34919 &                       1.2768 \\
% 	      45 & 12.8445 & 3.47436 &       8.5539 &    10.8552 &    12.2773 & 1.42303 &                       1.4362 \\
% 	      50 & 12.9245 & 3.58228 &       9.2702 &    11.2183 &    12.3990 & 1.40922 &                       1.3724 \\
% \bottomrule
% \end{tabular}
% \end{table}  

% The table is here too \ref{id:tab:wyniki}

%%%%%%%%%%%%%%%%%%%%%
% FIGURE FROM FILE
%
% \begin{figure}
% \centering
% \includegraphics[width=0.5\textwidth]{./graf/politechnika_sl_logo_bw_pion_en.pdf}
% \caption{Caption of a figure is always below the figure.}
% \label{fig:label}
% \end{figure}

% Fig. \ref{fig:label} presents asdasd

% \begin{figure}
% \includegraphics[width=0.5\textwidth]{./graf/test_image.jpg}
% \caption{Caption of a figure is always below the figure akakak.}
% \label{fig:duped_image3}
% \end{figure}

% some citation of the above \ref{fig:duped_image3}

%%%%%%%%%%%%%%%%%%%%%
%
%%%%%%%%%%%%%%%%%%%%
%% SUBFIGURES
%
% \begin{figure}
% \centering
% \begin{subfigure}{0.4\textwidth}
%    \includegraphics[width=\textwidth]{./graf/politechnika_sl_logo_bw_pion_en.pdf}
%    \caption{Upper left figure.}
%    \label{fig:upper-left}
% \end{subfigure}
% \hfill
% \begin{subfigure}{0.4\textwidth}
%    \includegraphics[width=\textwidth]{./graf/politechnika_sl_logo_bw_pion_en.pdf}
%    \caption{Upper right figure.}
%    \label{fig:upper-right}
% \end{subfigure}

% \begin{subfigure}{0.4\textwidth}
%    \includegraphics[width=\textwidth]{./graf/politechnika_sl_logo_bw_pion_en.pdf}
%    \caption{Lower left figure.}
%    \label{fig:lower-left}
% \end{subfigure}
% \hfill
% \begin{subfigure}{0.4\textwidth}
%    \includegraphics[width=\textwidth]{./graf/politechnika_sl_logo_bw_pion_en.pdf}
%    \caption{Lower right figure.}
%    \label{fig:lower-right}
% \end{subfigure}
       
% \caption{Common caption for all subfigures.}
% \label{fig:subfigures}
% \end{figure}
% Fig. \ref{fig:subfigures} presents very important information, eg. Fig. \ref{fig:upper-right} is an upper right subfigure.
%%%%%%%%%%%%%%%%%%%%%



% \begin{figure}
% \centering
% \begin{tikzpicture}
% \begin{axis}[
%    y tick label style={
%        /pgf/number format/.cd,
%            fixed,   % po zakomentowaniu os rzednych jest indeksowana wykladniczo
%            fixed zerofill, % 1.0 zamiast 1
%            precision=1,
%        /tikz/.cd
%    },
%    x tick label style={
%        /pgf/number format/.cd,
%            fixed,
%            fixed zerofill,
%            precision=2,
%        /tikz/.cd
%    }
% ]
% \addplot [domain=0.0:0.1] {rnd};
% \end{axis} 
% \end{tikzpicture}
% \caption{Figure caption is BELOW the figure.}
% \label{fig:3}
% \end{figure}

% \begin{figure}
% \centering
% \includegraphics[width=0.5\textwidth]{./graf/politechnika_sl_logo_bw_pion_en.pdf}
% \caption{Caption of a figure is always below the figure akakak.}
% \label{fig:3}
% \end{figure}

% some citation of the above \ref{fig:3}

% \begin{figure}
% \begin{lstlisting}
% if (_nClusters < 1)
% 	throw std::string ("unknown number of clusters");
% if (_nIterations < 1 and _epsilon < 0)
% 	throw std::string ("You should set a maximal number of iteration or minimal difference -- epsilon.");
% if (_nIterations > 0 and _epsilon > 0)
% 	throw std::string ("Both number of iterations and minimal epsilon set -- you should set either number of iterations or minimal epsilon.");
% \end{lstlisting}
% \caption{Example of pseudocode.}
% \end{figure}